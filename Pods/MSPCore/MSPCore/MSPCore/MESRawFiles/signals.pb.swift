// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: monetization/signals.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Com_Newsbreak_Monetization_Signals_SdkPlatform: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case ios // = 1
  case android // = 2
  case web // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ios
    case 2: self = .android
    case 3: self = .web
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ios: return 1
    case .android: return 2
    case .web: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Com_Newsbreak_Monetization_Signals_SdkPlatform] = [
    .unspecified,
    .ios,
    .android,
    .web,
  ]

}

enum Com_Newsbreak_Monetization_Signals_ConnectionType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0

  /// Ethernet; Wired Connection
  case ethernet // = 1

  /// WiFi
  case wifi // = 2

  /// Mobile Network - Unknown Generation
  case cellUnknown // = 3

  /// Mobile Network - 2G
  case cell2G // = 4

  /// Mobile Network - 3G
  case cell3G // = 5

  /// Mobile Network - 4G
  case cell4G // = 6

  /// Mobile Network - 5G
  case cell5G // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ethernet
    case 2: self = .wifi
    case 3: self = .cellUnknown
    case 4: self = .cell2G
    case 5: self = .cell3G
    case 6: self = .cell4G
    case 7: self = .cell5G
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ethernet: return 1
    case .wifi: return 2
    case .cellUnknown: return 3
    case .cell2G: return 4
    case .cell3G: return 5
    case .cell4G: return 6
    case .cell5G: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Com_Newsbreak_Monetization_Signals_ConnectionType] = [
    .unspecified,
    .ethernet,
    .wifi,
    .cellUnknown,
    .cell2G,
    .cell3G,
    .cell4G,
    .cell5G,
  ]

}

struct Com_Newsbreak_Monetization_Signals_DeviceSignal: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OpenRTB
  var make: String {
    get {return _storage._make}
    set {_uniqueStorage()._make = newValue}
  }

  /// OpenRTB
  /// We should not follow OpenRTB on iOS for this field
  /// The current Prebid SDK only shows "iPhone", but we
  /// need the hardware identifier here, for example:
  /// iPhone15,2 -> iPhone 14 Pro
  /// iPhone15,3 -> iPhone 14 Pro Max
  var model: String {
    get {return _storage._model}
    set {_uniqueStorage()._model = newValue}
  }

  /// OpenRTB
  var os: String {
    get {return _storage._os}
    set {_uniqueStorage()._os = newValue}
  }

  /// example: 15, 18.6.2
  var osv: String {
    get {return _storage._osv}
    set {_uniqueStorage()._osv = newValue}
  }

  /// For iOS it should be the kern.osversion, examples:
  /// 21G93 → iOS 17.6.1 (released Aug 7, 2024).
  /// 21H16 → iOS 17.7 (released Sept 16, 2024).
  /// For Android it is an underlying component of
  /// the Linux kernel that Android is built upon, examples:
  /// android15-6.6
  var kernelv: String {
    get {return _storage._kernelv}
    set {_uniqueStorage()._kernelv = newValue}
  }

  /// Physical width of the screen in pixels.
  var w: Int32 {
    get {return _storage._w}
    set {_uniqueStorage()._w = newValue}
  }

  /// Physical height of the screen in pixels.
  var h: Int32 {
    get {return _storage._h}
    set {_uniqueStorage()._h = newValue}
  }

  var orientation: String {
    get {return _storage._orientation}
    set {_uniqueStorage()._orientation = newValue}
  }

  var volumeLevel: Int32 {
    get {return _storage._volumeLevel}
    set {_uniqueStorage()._volumeLevel = newValue}
  }

  var brightness: Int32 {
    get {return _storage._brightness}
    set {_uniqueStorage()._brightness = newValue}
  }

  var batteryLevel: Int32 {
    get {return _storage._batteryLevel}
    set {_uniqueStorage()._batteryLevel = newValue}
  }

  /// unplugged, charging, full
  var batteryStatus: String {
    get {return _storage._batteryStatus}
    set {_uniqueStorage()._batteryStatus = newValue}
  }

  var thermalStatus: String {
    get {return _storage._thermalStatus}
    set {_uniqueStorage()._thermalStatus = newValue}
  }

  var totalMemoryBytes: UInt64 {
    get {return _storage._totalMemoryBytes}
    set {_uniqueStorage()._totalMemoryBytes = newValue}
  }

  var availableMemoryBytes: UInt64 {
    get {return _storage._availableMemoryBytes}
    set {_uniqueStorage()._availableMemoryBytes = newValue}
  }

  var totalStorageBytes: UInt64 {
    get {return _storage._totalStorageBytes}
    set {_uniqueStorage()._totalStorageBytes = newValue}
  }

  var availableStorageBytes: UInt64 {
    get {return _storage._availableStorageBytes}
    set {_uniqueStorage()._availableStorageBytes = newValue}
  }

  var isLowPowerMode: Bool {
    get {return _storage._isLowPowerMode}
    set {_uniqueStorage()._isLowPowerMode = newValue}
  }

  var isLowDataMode: Bool {
    get {return _storage._isLowDataMode}
    set {_uniqueStorage()._isLowDataMode = newValue}
  }

  var fontSize: String {
    get {return _storage._fontSize}
    set {_uniqueStorage()._fontSize = newValue}
  }

  /// light, dark, system
  var theme: String {
    get {return _storage._theme}
    set {_uniqueStorage()._theme = newValue}
  }

  /// OpenRTB
  var carrier: String {
    get {return _storage._carrier}
    set {_uniqueStorage()._carrier = newValue}
  }

  /// OpenRTB
  var mccmnc: String {
    get {return _storage._mccmnc}
    set {_uniqueStorage()._mccmnc = newValue}
  }

  var connectionType: Com_Newsbreak_Monetization_Signals_ConnectionType {
    get {return _storage._connectionType}
    set {_uniqueStorage()._connectionType = newValue}
  }

  /// Locale.current.region?.identifier   // e.g. "US", "GB", "CN" (ISO 3166-1)
  var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  /// "America/Los_Angeles"
  var timezone: String {
    get {return _storage._timezone}
    set {_uniqueStorage()._timezone = newValue}
  }

  /// ordered [String], e.g. ["en-US","zh-Hans-US"]
  var locale: String {
    get {return _storage._locale}
    set {_uniqueStorage()._locale = newValue}
  }

  /// OpenRTB
  var ua: String {
    get {return _storage._ua}
    set {_uniqueStorage()._ua = newValue}
  }

  /// IDFA, GAID, etc.
  var ifa: String {
    get {return _storage._ifa}
    set {_uniqueStorage()._ifa = newValue}
  }

  /// iOS IDFV, Android App Set Id, etc.
  var ifv: String {
    get {return _storage._ifv}
    set {_uniqueStorage()._ifv = newValue}
  }

  /// OpenRTB
  var lmt: Bool {
    get {return _storage._lmt}
    set {_uniqueStorage()._lmt = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Com_Newsbreak_Monetization_Signals_AppSignal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OpenRTB
  var name: String = String()

  /// For mobile apps
  var bundle: String = String()

  /// OpenRTB
  var ver: String = String()

  /// For websites, the domain of the website
  var domain: String = String()

  /// For websites, the page URL of the website
  var page: String = String()

  var ppid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Newsbreak_Monetization_Signals_SDKSignal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orgID: Int32 = 0

  var appID: Int32 = 0

  var mspID: String = String()

  var sdkVersion: String = String()

  var platform: Com_Newsbreak_Monetization_Signals_SdkPlatform = .unspecified

  var clientTs: Int64 = 0

  /// An UUID generated and persisted at client side
  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Newsbreak_Monetization_Signals_ServerSignal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverTs: Int64 = 0

  var ip: String = String()

  /// unique uuid for each event
  var eventID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.newsbreak.monetization.signals"

extension Com_Newsbreak_Monetization_Signals_SdkPlatform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SDK_PLATFORM_UNSPECIFIED"),
    1: .same(proto: "SDK_PLATFORM_IOS"),
    2: .same(proto: "SDK_PLATFORM_ANDROID"),
    3: .same(proto: "SDK_PLATFORM_WEB"),
  ]
}

extension Com_Newsbreak_Monetization_Signals_ConnectionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_TYPE_UNSPECIFIED"),
    1: .same(proto: "CONNECTION_TYPE_ETHERNET"),
    2: .same(proto: "CONNECTION_TYPE_WIFI"),
    3: .same(proto: "CONNECTION_TYPE_CELL_UNKNOWN"),
    4: .same(proto: "CONNECTION_TYPE_CELL_2G"),
    5: .same(proto: "CONNECTION_TYPE_CELL_3G"),
    6: .same(proto: "CONNECTION_TYPE_CELL_4G"),
    7: .same(proto: "CONNECTION_TYPE_CELL_5G"),
  ]
}

extension Com_Newsbreak_Monetization_Signals_DeviceSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceSignal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "make"),
    2: .same(proto: "model"),
    3: .same(proto: "os"),
    4: .same(proto: "osv"),
    5: .same(proto: "kernelv"),
    6: .same(proto: "w"),
    7: .same(proto: "h"),
    8: .same(proto: "orientation"),
    9: .standard(proto: "volume_level"),
    10: .same(proto: "brightness"),
    11: .standard(proto: "battery_level"),
    12: .standard(proto: "battery_status"),
    13: .standard(proto: "thermal_status"),
    14: .standard(proto: "total_memory_bytes"),
    15: .standard(proto: "available_memory_bytes"),
    16: .standard(proto: "total_storage_bytes"),
    17: .standard(proto: "available_storage_bytes"),
    18: .standard(proto: "is_low_power_mode"),
    19: .standard(proto: "is_low_data_mode"),
    20: .standard(proto: "font_size"),
    21: .same(proto: "theme"),
    22: .same(proto: "carrier"),
    23: .same(proto: "mccmnc"),
    24: .standard(proto: "connection_type"),
    25: .same(proto: "country"),
    26: .same(proto: "timezone"),
    27: .same(proto: "locale"),
    28: .same(proto: "ua"),
    29: .same(proto: "ifa"),
    30: .same(proto: "ifv"),
    31: .same(proto: "lmt"),
  ]

  fileprivate class _StorageClass {
    var _make: String = String()
    var _model: String = String()
    var _os: String = String()
    var _osv: String = String()
    var _kernelv: String = String()
    var _w: Int32 = 0
    var _h: Int32 = 0
    var _orientation: String = String()
    var _volumeLevel: Int32 = 0
    var _brightness: Int32 = 0
    var _batteryLevel: Int32 = 0
    var _batteryStatus: String = String()
    var _thermalStatus: String = String()
    var _totalMemoryBytes: UInt64 = 0
    var _availableMemoryBytes: UInt64 = 0
    var _totalStorageBytes: UInt64 = 0
    var _availableStorageBytes: UInt64 = 0
    var _isLowPowerMode: Bool = false
    var _isLowDataMode: Bool = false
    var _fontSize: String = String()
    var _theme: String = String()
    var _carrier: String = String()
    var _mccmnc: String = String()
    var _connectionType: Com_Newsbreak_Monetization_Signals_ConnectionType = .unspecified
    var _country: String = String()
    var _timezone: String = String()
    var _locale: String = String()
    var _ua: String = String()
    var _ifa: String = String()
    var _ifv: String = String()
    var _lmt: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _make = source._make
      _model = source._model
      _os = source._os
      _osv = source._osv
      _kernelv = source._kernelv
      _w = source._w
      _h = source._h
      _orientation = source._orientation
      _volumeLevel = source._volumeLevel
      _brightness = source._brightness
      _batteryLevel = source._batteryLevel
      _batteryStatus = source._batteryStatus
      _thermalStatus = source._thermalStatus
      _totalMemoryBytes = source._totalMemoryBytes
      _availableMemoryBytes = source._availableMemoryBytes
      _totalStorageBytes = source._totalStorageBytes
      _availableStorageBytes = source._availableStorageBytes
      _isLowPowerMode = source._isLowPowerMode
      _isLowDataMode = source._isLowDataMode
      _fontSize = source._fontSize
      _theme = source._theme
      _carrier = source._carrier
      _mccmnc = source._mccmnc
      _connectionType = source._connectionType
      _country = source._country
      _timezone = source._timezone
      _locale = source._locale
      _ua = source._ua
      _ifa = source._ifa
      _ifv = source._ifv
      _lmt = source._lmt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._make) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._model) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._os) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._osv) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._kernelv) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._w) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._h) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._orientation) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._volumeLevel) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._brightness) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._batteryLevel) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._batteryStatus) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._thermalStatus) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalMemoryBytes) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._availableMemoryBytes) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalStorageBytes) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._availableStorageBytes) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._isLowPowerMode) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isLowDataMode) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._fontSize) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._theme) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._carrier) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._mccmnc) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._connectionType) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._country) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._timezone) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._locale) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._ua) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._ifa) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._ifv) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._lmt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._make.isEmpty {
        try visitor.visitSingularStringField(value: _storage._make, fieldNumber: 1)
      }
      if !_storage._model.isEmpty {
        try visitor.visitSingularStringField(value: _storage._model, fieldNumber: 2)
      }
      if !_storage._os.isEmpty {
        try visitor.visitSingularStringField(value: _storage._os, fieldNumber: 3)
      }
      if !_storage._osv.isEmpty {
        try visitor.visitSingularStringField(value: _storage._osv, fieldNumber: 4)
      }
      if !_storage._kernelv.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kernelv, fieldNumber: 5)
      }
      if _storage._w != 0 {
        try visitor.visitSingularInt32Field(value: _storage._w, fieldNumber: 6)
      }
      if _storage._h != 0 {
        try visitor.visitSingularInt32Field(value: _storage._h, fieldNumber: 7)
      }
      if !_storage._orientation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orientation, fieldNumber: 8)
      }
      if _storage._volumeLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._volumeLevel, fieldNumber: 9)
      }
      if _storage._brightness != 0 {
        try visitor.visitSingularInt32Field(value: _storage._brightness, fieldNumber: 10)
      }
      if _storage._batteryLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._batteryLevel, fieldNumber: 11)
      }
      if !_storage._batteryStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._batteryStatus, fieldNumber: 12)
      }
      if !_storage._thermalStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._thermalStatus, fieldNumber: 13)
      }
      if _storage._totalMemoryBytes != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalMemoryBytes, fieldNumber: 14)
      }
      if _storage._availableMemoryBytes != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._availableMemoryBytes, fieldNumber: 15)
      }
      if _storage._totalStorageBytes != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalStorageBytes, fieldNumber: 16)
      }
      if _storage._availableStorageBytes != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._availableStorageBytes, fieldNumber: 17)
      }
      if _storage._isLowPowerMode != false {
        try visitor.visitSingularBoolField(value: _storage._isLowPowerMode, fieldNumber: 18)
      }
      if _storage._isLowDataMode != false {
        try visitor.visitSingularBoolField(value: _storage._isLowDataMode, fieldNumber: 19)
      }
      if !_storage._fontSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fontSize, fieldNumber: 20)
      }
      if !_storage._theme.isEmpty {
        try visitor.visitSingularStringField(value: _storage._theme, fieldNumber: 21)
      }
      if !_storage._carrier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrier, fieldNumber: 22)
      }
      if !_storage._mccmnc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mccmnc, fieldNumber: 23)
      }
      if _storage._connectionType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._connectionType, fieldNumber: 24)
      }
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 25)
      }
      if !_storage._timezone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timezone, fieldNumber: 26)
      }
      if !_storage._locale.isEmpty {
        try visitor.visitSingularStringField(value: _storage._locale, fieldNumber: 27)
      }
      if !_storage._ua.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ua, fieldNumber: 28)
      }
      if !_storage._ifa.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ifa, fieldNumber: 29)
      }
      if !_storage._ifv.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ifv, fieldNumber: 30)
      }
      if _storage._lmt != false {
        try visitor.visitSingularBoolField(value: _storage._lmt, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Newsbreak_Monetization_Signals_DeviceSignal, rhs: Com_Newsbreak_Monetization_Signals_DeviceSignal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._make != rhs_storage._make {return false}
        if _storage._model != rhs_storage._model {return false}
        if _storage._os != rhs_storage._os {return false}
        if _storage._osv != rhs_storage._osv {return false}
        if _storage._kernelv != rhs_storage._kernelv {return false}
        if _storage._w != rhs_storage._w {return false}
        if _storage._h != rhs_storage._h {return false}
        if _storage._orientation != rhs_storage._orientation {return false}
        if _storage._volumeLevel != rhs_storage._volumeLevel {return false}
        if _storage._brightness != rhs_storage._brightness {return false}
        if _storage._batteryLevel != rhs_storage._batteryLevel {return false}
        if _storage._batteryStatus != rhs_storage._batteryStatus {return false}
        if _storage._thermalStatus != rhs_storage._thermalStatus {return false}
        if _storage._totalMemoryBytes != rhs_storage._totalMemoryBytes {return false}
        if _storage._availableMemoryBytes != rhs_storage._availableMemoryBytes {return false}
        if _storage._totalStorageBytes != rhs_storage._totalStorageBytes {return false}
        if _storage._availableStorageBytes != rhs_storage._availableStorageBytes {return false}
        if _storage._isLowPowerMode != rhs_storage._isLowPowerMode {return false}
        if _storage._isLowDataMode != rhs_storage._isLowDataMode {return false}
        if _storage._fontSize != rhs_storage._fontSize {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._carrier != rhs_storage._carrier {return false}
        if _storage._mccmnc != rhs_storage._mccmnc {return false}
        if _storage._connectionType != rhs_storage._connectionType {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._timezone != rhs_storage._timezone {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._ua != rhs_storage._ua {return false}
        if _storage._ifa != rhs_storage._ifa {return false}
        if _storage._ifv != rhs_storage._ifv {return false}
        if _storage._lmt != rhs_storage._lmt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Newsbreak_Monetization_Signals_AppSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSignal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "bundle"),
    3: .same(proto: "ver"),
    4: .same(proto: "domain"),
    5: .same(proto: "page"),
    6: .same(proto: "ppid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bundle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ver) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.page) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.ppid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.bundle.isEmpty {
      try visitor.visitSingularStringField(value: self.bundle, fieldNumber: 2)
    }
    if !self.ver.isEmpty {
      try visitor.visitSingularStringField(value: self.ver, fieldNumber: 3)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 4)
    }
    if !self.page.isEmpty {
      try visitor.visitSingularStringField(value: self.page, fieldNumber: 5)
    }
    if !self.ppid.isEmpty {
      try visitor.visitSingularStringField(value: self.ppid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Newsbreak_Monetization_Signals_AppSignal, rhs: Com_Newsbreak_Monetization_Signals_AppSignal) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.bundle != rhs.bundle {return false}
    if lhs.ver != rhs.ver {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.page != rhs.page {return false}
    if lhs.ppid != rhs.ppid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Newsbreak_Monetization_Signals_SDKSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SDKSignal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "org_id"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "msp_id"),
    4: .standard(proto: "sdk_version"),
    5: .same(proto: "platform"),
    6: .standard(proto: "client_ts"),
    7: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.orgID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mspID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sdkVersion) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.clientTs) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orgID != 0 {
      try visitor.visitSingularInt32Field(value: self.orgID, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularInt32Field(value: self.appID, fieldNumber: 2)
    }
    if !self.mspID.isEmpty {
      try visitor.visitSingularStringField(value: self.mspID, fieldNumber: 3)
    }
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 4)
    }
    if self.platform != .unspecified {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 5)
    }
    if self.clientTs != 0 {
      try visitor.visitSingularInt64Field(value: self.clientTs, fieldNumber: 6)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Newsbreak_Monetization_Signals_SDKSignal, rhs: Com_Newsbreak_Monetization_Signals_SDKSignal) -> Bool {
    if lhs.orgID != rhs.orgID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.mspID != rhs.mspID {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.clientTs != rhs.clientTs {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Newsbreak_Monetization_Signals_ServerSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerSignal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_ts"),
    2: .same(proto: "ip"),
    3: .standard(proto: "event_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverTs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverTs != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTs, fieldNumber: 1)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 2)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Newsbreak_Monetization_Signals_ServerSignal, rhs: Com_Newsbreak_Monetization_Signals_ServerSignal) -> Bool {
    if lhs.serverTs != rhs.serverTs {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
